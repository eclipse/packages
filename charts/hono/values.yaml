#
# Copyright (c) 2019, 2023 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0
#
# SPDX-License-Identifier: EPL-2.0
#

# Default values for eclipse-hono.
# Declare variables to be passed into your templates.

nameOverride: ""
fullnameOverride: ""

# honoImagesTag contains the (common) tag name of the Hono component
# container images to deploy.
# If not set explicitly, the chart's appVersion is used as the tag name.
# Alternatively, the tag name can also be set per component image.
# honoImagesTag:

# honoContainerRegistry contains the name of the container registry that
# the container images for Hono's components should be pulled from.
# The registry can also be set separately for each component, overriding
# the value specified here.
honoContainerRegistry: "index.docker.io"

# imagePullSecrets for pulling docker images from private registry. It will
# be added to every deployment and statefulset.
imagePullSecrets: []

# probes allows you to configure http GET probes on most hono services
# the values below will be used by default but can be overwritten by
# configuring more specific config in the probes config of the component.
# Note that only the parameters below can be overwritten.
probes:
  livenessProbe:
    httpGet:
      path: "/liveness"
      port: "health"
      scheme: "HTTP"
    periodSeconds: 10
    failureThreshold: 3
    initialDelaySeconds: 300
    successThreshold: 1
    timeoutSeconds: 3
  readinessProbe:
    httpGet:
      path: "/readiness"
      port: "health"
      scheme: "HTTP"
    periodSeconds: 10
    failureThreshold: 3
    initialDelaySeconds: 20
    successThreshold: 1
    timeoutSeconds: 3

# color indicates if the information printed to the console by components should be
# formatted in multi-color using ANSI escape sequences.
console:
  color: false

# [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the default value to use
# for the "initialDelaySeconds" configuration property of a Hono
# component's liveness probe.
# The value can be overridden by the corresponding property at the
# component level.
livenessProbeInitialDelaySeconds:
# [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the default value to use
# for the "initialDelaySeconds" configuration property of a Hono
# component's readiness probe.
# The value can be overridden by the corresponding property at the
# component level.
readinessProbeInitialDelaySeconds:

# platform indicates the type of container orchestration platform we are deploying to.
# Supported values are:
# - openshift
# - kubernetes
#
# When setting to "openshift", Route resources will also be deployed.
platform: "kubernetes"

# useLoadBalancer indicates whether services should be deployed using the
# "LoadBalancer" type (true) or the "NodePort" type (false).
# This property will be ignored when deploying to platform "openshift" or when serviceType
# (see below) is configured.
useLoadBalancer: true

# serviceType indicates which service type services should have.
# Possible serviceTypes are described on
# https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
serviceType:

# messagingNetworkTypes indicates the type(s) of messaging to be used.
# The following types are defined:
# - kafka: Apache Kafka based messaging. Also refer to the
#     sections "kafkaMessagingClusterExample" and "adapters.kafkaMessagingSpec"
# - amqp: AMQP 1.0 based messaging. Also refer to the
#     sections "amqpMessagingNetworkExample" and "adapters.amqpMessagingNetworkSpec".
messagingNetworkTypes:
- "kafka"

# Configuration properties for protocol adapters.
adapters:

  # externalAdaptersEnabled indicates whether protocol adapters that
  # run outside of the kubernetes cluster should be allowed to connect to
  # the Dispatch Router and the example device registry's service endpoints.
  # The default setting is 'false' which prevents access from outside of the
  # cluster.
  # Setting this property to 'true' allows external adapters to connect to
  # the Dispatch Router's 'internal' endpoint and the Device Registry's
  # service endpoints via AMQPS, i.e. AMQP over TLS.
  # The Dispatch Router's 'internal' endpoint listens on port 15673 and requires
  # adapters to authenticate using SASL EXTERNAL, i.e. an adapter needs to provide
  # a client certificate that has been signed by one of the CA certs contained in
  # the router's trust store.
  # When opening the AMQP connection to the router, the adapter needs to indicate
  # the 'hono-internal' virtual host name in its AMQP 1.0 'open' frame.
  # The example Device Registry's AMQPS endpoint requires adapters to authenticate
  # using SASL PLAIN, i.e. an adapter needs to provide a username and password which
  # can be verified by the Auth Server component.
  externalAdaptersEnabled: false

  # amqpMessagingNetworkSpec contains Hono client properties used by all protocol
  # adapters for connecting to the AMQP Messaging Network to forward downstream messages to.
  # This property MUST be set if "messagingNetworkTypes" contains "amqp" and
  # "amqpMessagingNetworkExample.enabled" is set to false.
  # Please refer to https://www.eclipse.org/hono/docs/admin-guide/hono-client-configuration/
  # for a description of supported properties.
  # However, if "amqpMessagingNetworkExample.enabled" is set to true, only
  # "keyPath", "certPath", "trustStorePath", "hostnameVerificationRequired" can be set.
  amqpMessagingNetworkSpec:
    keyPath: "/opt/hono/tls/tls.key"
    certPath: "/opt/hono/tls/tls.crt"
    trustStorePath: "/opt/hono/tls/ca.crt"
    hostnameVerificationRequired: false
  #  host: "my-amqp-host"
  #  port: 5671
  #  credentialsPath: "/etc/conf/amqp-credentials.properties"

  # commandAndControlSpec contains Hono client properties used by all protocol
  # adapters for connecting to the AMQP Messaging Network which is used by applications
  # to send commands to devices.
  # This property MUST be set if "messagingNetworkTypes" contains "amqp" and
  # "amqpMessagingNetworkExample.enabled" is set to false.
  # Please refer to https://www.eclipse.org/hono/docs/admin-guide/hono-client-configuration/
  # for a description of supported properties.
  # However, if "amqpMessagingNetworkExample.enabled" is set to true, only
  # "keyPath", "certPath", "trustStorePath", "hostnameVerificationRequired" can be set.
  commandAndControlSpec:
    keyPath: "/opt/hono/tls/tls.key"
    certPath: "/opt/hono/tls/tls.crt"
    trustStorePath: "/opt/hono/tls/ca.crt"
    hostnameVerificationRequired: false

  # kafkaMessagingSpec contains the configuration used by all protocol
  # adapters for connecting to the Kafka cluster to be used for messaging.
  # This property MUST be set if "messagingNetworkTypes" contains "kafka" and
  # "kafkaMessagingClusterExample.enabled" is set to false.
  # Please refer to https://www.eclipse.org/hono/docs/admin-guide/common-config/#kafka-based-messaging-configuration
  # for a description of supported properties.
  kafkaMessagingSpec: {}
  #  commonClientConfig:
  #    "bootstrap.servers": "broker0.my-custom-kafka.org:9092,broker1.my-custom-kafka.org:9092"
  #  command:
  #    consumerConfig:
  #      "compression.type": none
  #  commandInternal:
  #    adminClientConfig:
  #      "compression.type": none
  #  commandResponse:
  #    producerConfig:
  #      "compression.type": none
  #  event:
  #    producerConfig:
  #      "compression.type": none
  #  notification:
  #    consumerConfig:
  #      "compression.type": none
  #  telemetry:
  #    producerConfig:
  #      "compression.type": none

  # tenantSpec contains Hono client properties used by all protocol adapters for
  # connecting to the Tenant service.
  # This property MUST be set if "deviceRegistryExample.enabled" is set to false.
  # Please refer to https://www.eclipse.org/hono/docs/admin-guide/hono-client-configuration/
  # for a description of supported properties.
  tenantSpec:

  # deviceRegistrationSpec contains Hono client properties used by all protocol adapters for
  # connecting to the Device Registration service.
  # This property MUST be set if "deviceRegistryExample.enabled" is set to false.
  # Please refer to https://www.eclipse.org/hono/docs/admin-guide/hono-client-configuration/
  # for a description of supported properties.
  deviceRegistrationSpec:

  # credentialsSpec contains Hono client properties used by all protocol adapters for
  # connecting to the Credentials service.
  # This property MUST be set if "deviceRegistryExample.enabled" is set to false.
  # Please refer to https://www.eclipse.org/hono/docs/admin-guide/hono-client-configuration/
  # for a description of supported properties.
  credentialsSpec:

  # commandRouterSpec contains Hono client properties used by all protocol adapters for
  # connecting to the Command Router service.
  # If not set, default properties will be used for establishing a TLS based connection
  # to the command router server.
  # Please refer to https://www.eclipse.org/hono/docs/admin-guide/hono-client-configuration/
  # for a description of supported properties.
  commandRouterSpec:

  # tenantIdleTimeout contains the amount of time of inactivity after which protocol adapters
  # close tenant specific links to services they interact with.
  # Please refer to the Java documentation for the supported syntax:
  # https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/Duration.html#parse(java.lang.CharSequence)
  defaultTenantIdleTimeout: "1h"

  # mapperEndpoints contains configuration properties for the adapter's
  # used mapper endpoints.
  # If not set, the adapter by default has no mappers configured
  mapperEndpoints:
  #  mapperName:
  #    host: "eclipse.org"
  #    uri: "/hono/map"
  #    ssl: true
  #    port: 443

  amqp:
    # enabled indicates if Hono's AMQP 1.0 adapter should be deployed.
    enabled: true
    # imageName contains the name (excluding registry)
    # of the container image to use for the AMQP adapter
    imageName: "eclipse/hono-adapter-amqp"
    # imageTag contains the tag of the container image to deploy.
    # If not specified, the value of the honoImagesTag property is used.
    # imageTag:
    # containerRegistry contains the name of the container registry to pull
    # the image from.
    # If not specified, the value of the "honoContainerRegistry" property is used.
    # containerRegistry:
    # javaOptions contains options to pass to the JVM when starting
    # up the service
    javaOptions: "-XX:MinRAMPercentage=80 -XX:MaxRAMPercentage=80"
    # cmdLineArgs contains additional arguments to be passed to the container's CMD.
    cmdLineArgs: []
    # quarkusConfigLocations contains resources that the Quarkus based variant of the component should read
    # additional configuration from.
    # Properties are read in the following sequence with properties further down in the list overwriting property
    # values read from resources further up in the list.
    # 1. Properties defined in file "/opt/hono/application.yml".
    # 2. Properties read from the resources defined here.
    # 3. Properties defined in operating system environment variables.
    # 4. Properties defined in Java system properties.
    # See https://smallrye.io/docs/smallrye-config/config/config.html#locations for details regarding supported resource
    # types.
    # If not set, default resources configuring logging levels based on the value of "quarkusLoggingProfile" are
    # being read.
    quarkusConfigLocations:
    # quarkusLoggingProfile indicates at which level the Quarkus based variant of the component should log.
    # Supported values are "prod", "dev" or "trace"
    quarkusLoggingProfile: "dev"
    # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's liveness probe.
    # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
    livenessProbeInitialDelaySeconds:
    # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's readiness probe.
    # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
    readinessProbeInitialDelaySeconds:
    # probes allows you to overwrite the global probes config values for this specific component
    probes: {}
    # resources contains the container's requests and limits for CPU and memory
    # as defined by the Kubernetes API.
    # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    # for a description of the properties' semantics.
    resources:
      requests:
        cpu: "150m"
        memory: "300Mi"
      limits:
        cpu: "1"
        memory: "512Mi"

    svc:
      annotations: {}
      loadBalancerIP:

    deployment:
      annotations: {}

    pod:
      labels: {}
      annotations: {}
      priorityClassName: ""
      affinity: {}

    # extraVolumes contains additional kubernetes Volume definitions representing volumes
    # that can mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
    # This can be used to provide the container access to files contained in kubernetes
    # Secrets and/or ConfigMaps.
    extraVolumes: []

    # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
    # should be mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
    # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
    # file system and then refer to the contained files in the component's configuration,
    # e.g. public and private keys or an application.yaml file.
    extraVolumeMounts: []

    # The configMap to get additional environment variables from for this adapter.
    envConfigMap:
    # The secret to get additional environment variables from for this adapter.
    envSecret:

    # tlsKeysSecret identifies the Secret that contains the key material which should be used for
    # securing the component's exposed API endpoint(s).
    #
    # Possible values are:
    # "example" - create and use example keys, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a private key file
    #              named "tls.key" and an X.509 certificate file named "tls.crt".
    #              The file names have been chosen deliberately to match those produced by the
    #              cert-manager operator (https://cert-manager.io/).
    # "none" - do not create keys nor mount an existing secret containing keys
    tlsKeysSecret: "example"

    # tlsTrustStoreConfigMap identifies the ConfigMap that contains the certificates which should
    # be used as the trust anchor by this component when it needs to authenticate server identities
    # during a TLS handshake.
    #
    # Possible values are:
    # "example" - create and use example CA certificates, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a PEM file
    #              named "ca.crt" which contains X.509 certificates to be used as the trust anchor.
    # "none" - do not mount an existing secret containing certificates. This might be useful if the
    #          component does not open any TLS connections to other hosts.
    tlsTrustStoreConfigMap: "example"

    # hono contains the adapter's configuration properties as defined in
    # https://www.eclipse.org/hono/docs/admin-guide/amqp-adapter-config/
    hono:
      app:
        # maxInstances defines the number of adapter Verticle instances to deploy
        # to the vert.x runtime during start-up.
        maxInstances: 1

      # amqp contains configuration properties for the adapter's
      # exposed AMQP endpoints.
      # If not set, the adapter by default exposes the secure and insecure ports
      # using an example key and certificate.
      amqp: {}
      #  insecurePortEnabled: true
      #  insecurePortBindAddress: "0.0.0.0"

  coap:
    # enabled indicates if Hono's CoAP adapter should be deployed.
    enabled: false
    # imageName contains the name (excluding registry)
    # of the container image to use for the CoAP adapter
    imageName: "eclipse/hono-adapter-coap"
    # imageTag contains the tag of the container image to deploy.
    # If not specified, the value of the honoImagesTag property is used.
    # imageTag:
    # containerRegistry contains the name of the container registry to pull
    # the image from.
    # If not specified, the value of the "honoContainerRegistry" property is used.
    # containerRegistry:
    # javaOptions contains options to pass to the JVM when starting
    # up the service
    javaOptions: "-XX:MinRAMPercentage=80 -XX:MaxRAMPercentage=80"
    # cmdLineArgs contains additional arguments to be passed to the container's CMD.
    cmdLineArgs: []
    # quarkusConfigLocations contains resources that the Quarkus based variant of the component should read
    # additional configuration from.
    # Properties are read in the following sequence with properties further down in the list overwriting property
    # values read from resources further up in the list.
    # 1. Properties defined in file "/opt/hono/application.yml".
    # 2. Properties read from the resources defined here.
    # 3. Properties defined in operating system environment variables.
    # 4. Properties defined in Java system properties.
    # See https://smallrye.io/docs/smallrye-config/config/config.html#locations for details regarding supported resource
    # types.
    # If not set, default resources configuring logging levels based on the value of "quarkusLoggingProfile" are
    # being read.
    quarkusConfigLocations:
    # quarkusLoggingProfile indicates at which level the Quarkus based variant of the component should log.
    # Supported values are "prod", "dev" or "trace"
    quarkusLoggingProfile: "dev"
    # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's liveness probe.
    # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
    livenessProbeInitialDelaySeconds:
    # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's readiness probe.
    # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
    readinessProbeInitialDelaySeconds:
    # probes allows you to overwrite the global probes config values for this specific component
    probes: {}
    # resources contains the container's requests and limits for CPU and memory
    # as defined by the Kubernetes API.
    # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    # for a description of the properties' semantics.
    resources:
      requests:
        cpu: "150m"
        memory: "256Mi"
      limits:
        cpu: "1"
        memory: "512Mi"

    svc:
      annotations: {}
      loadBalancerIP:

    deployment:
      annotations: {}

    pod:
      labels: {}
      annotations: {}
      priorityClassName: ""
      affinity: {}

    # extraVolumes contains additional kubernetes Volume definitions representing volumes
    # that can mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
    # This can be used to provide the container access to files contained in kubernetes
    # Secrets and/or ConfigMaps.
    extraVolumes: []

    # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
    # should be mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
    # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
    # file system and then refer to the contained files in the component's configuration,
    # e.g. public and private keys or an application.yaml file.
    extraVolumeMounts: []

    # The configMap to get additional environment variables from for this adapter.
    envConfigMap:
    # The secret to get additional environment variables from for this adapter.
    envSecret:

    # tlsKeysSecret identifies the Secret that contains the key material which should be used for
    # securing the component's exposed API endpoint(s).
    #
    # Possible values are:
    # "example" - create and use example keys, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a private key file
    #              named "tls.key" and an X.509 certificate file named "tls.crt".
    #              The file names have been chosen deliberately to match those produced by the
    #              cert-manager operator (https://cert-manager.io/).
    # "none" - do not create keys nor mount an existing secret containing keys
    tlsKeysSecret: "example"

    # tlsTrustStoreConfigMap identifies the ConfigMap that contains the certificates which should
    # be used as the trust anchor by this component when it needs to authenticate server identities
    # during a TLS handshake.
    #
    # Possible values are:
    # "example" - create and use example CA certificates, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a PEM file
    #              named "ca.crt" which contains X.509 certificates to be used as the trust anchor.
    # "none" - do not mount an existing secret containing certificates. This might be useful if the
    #          component does not open any TLS connections to other hosts.
    tlsTrustStoreConfigMap: "example"

    # hono contains the adapter's configuration properties
    hono:
      app:
        # maxInstances defines the number of adapter Verticle instances to deploy
        # to the vert.x runtime during start-up.
        maxInstances: 1
      # coap contains configuration properties for the adapter's
      # exposed CoAP endpoints.
      # If not set, the adapter by default exposes the secure port
      # using an example key and certificate.
      coap: {}
      #  insecurePortEnabled: true
      #  insecurePortBindAddress: "0.0.0.0"

  http:
    # enabled indicates if Hono's HTTP adapter should be deployed.
    enabled: true
    # imageName contains the name (excluding registry)
    # of the container image to use for the HTTP adapter
    imageName: "eclipse/hono-adapter-http"
    # imageTag contains the tag of the container image to deploy.
    # If not specified, the value of the honoImagesTag property is used.
    # imageTag:
    # containerRegistry contains the name of the container registry to pull
    # the image from.
    # If not specified, the value of the "honoContainerRegistry" property is used.
    # containerRegistry:
    # javaOptions contains options to pass to the JVM when starting
    # up the service
    javaOptions: "-XX:MinRAMPercentage=80 -XX:MaxRAMPercentage=80"
    # cmdLineArgs contains additional arguments to be passed to the container's CMD.
    cmdLineArgs: []
    # quarkusConfigLocations contains resources that the Quarkus based variant of the component should read
    # additional configuration from.
    # Properties are read in the following sequence with properties further down in the list overwriting property
    # values read from resources further up in the list.
    # 1. Properties defined in file "/opt/hono/application.yml".
    # 2. Properties read from the resources defined here.
    # 3. Properties defined in operating system environment variables.
    # 4. Properties defined in Java system properties.
    # See https://smallrye.io/docs/smallrye-config/config/config.html#locations for details regarding supported resource
    # types.
    # If not set, default resources configuring logging levels based on the value of "quarkusLoggingProfile" are
    # being read.
    quarkusConfigLocations:
    # quarkusLoggingProfile indicates at which level the Quarkus based variant of the component should log.
    # Supported values are "prod", "dev" or "trace"
    quarkusLoggingProfile: "dev"
    # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's liveness probe.
    # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
    livenessProbeInitialDelaySeconds:
    # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's readiness probe.
    # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
    readinessProbeInitialDelaySeconds:
    # probes allows you to overwrite the global probes config values for this specific component
    probes: {}
    # resources contains the container's requests and limits for CPU and memory
    # as defined by the Kubernetes API.
    # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    # for a description of the properties' semantics.
    resources:
      requests:
        cpu: "150m"
        memory: "300Mi"
      limits:
        cpu: "1"
        memory: "512Mi"

    svc:
      annotations: {}
      loadBalancerIP:

    deployment:
      annotations: {}

    pod:
      labels: {}
      annotations: {}
      priorityClassName: ""
      affinity: {}

    # extraVolumes contains additional kubernetes Volume definitions representing volumes
    # that can mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
    # This can be used to provide the container access to files contained in kubernetes
    # Secrets and/or ConfigMaps.
    extraVolumes: []

    # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
    # should be mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
    # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
    # file system and then refer to the contained files in the component's configuration,
    # e.g. public and private keys or an application.yaml file.
    extraVolumeMounts: []

    # The configMap to get additional environment variables from for this adapter.
    envConfigMap:
    # The secret to get additional environment variables from for this adapter.
    envSecret:

    # tlsKeysSecret identifies the Secret that contains the key material which should be used for
    # securing the component's exposed API endpoint(s).
    #
    # Possible values are:
    # "example" - create and use example keys, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a private key file
    #              named "tls.key" and an X.509 certificate file named "tls.crt".
    #              The file names have been chosen deliberately to match those produced by the
    #              cert-manager operator (https://cert-manager.io/).
    # "none" - do not create keys nor mount an existing secret containing keys
    tlsKeysSecret: "example"

    # tlsTrustStoreConfigMap identifies the ConfigMap that contains the certificates which should
    # be used as the trust anchor by this component when it needs to authenticate server identities
    # during a TLS handshake.
    #
    # Possible values are:
    # "example" - create and use example CA certificates, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a PEM file
    #              named "ca.crt" which contains X.509 certificates to be used as the trust anchor.
    # "none" - do not mount an existing secret containing certificates. This might be useful if the
    #          component does not open any TLS connections to other hosts.
    tlsTrustStoreConfigMap: "example"

    # hono contains the adapter's configuration properties as defined in
    # https://www.eclipse.org/hono/docs/admin-guide/http-adapter-config/
    hono:
      app:
        # maxInstances defines the number of adapter Verticle instances to deploy
        # to the vert.x runtime during start-up.
        maxInstances: 1

      # http contains configuration properties for the adapter's
      # exposed HTTP endpoints.
      # If not set, the adapter by default exposes the secure and insecure ports
      # using an example key and certificate.
      http: {}
      #  insecurePortEnabled: true
      #  insecurePortBindAddress: "0.0.0.0"

  lora:
    # enabled indicates if Hono's Lora adapter should be deployed.
    enabled: false
    # imageName contains the name (excluding registry)
    # of the container image to use for the LoRa adapter
    imageName: "eclipse/hono-adapter-lora"
    # imageTag contains the tag of the container image to deploy.
    # If not specified, the value of the honoImagesTag property is used.
    # imageTag:
    # containerRegistry contains the name of the container registry to pull
    # the image from.
    # If not specified, the value of the "honoContainerRegistry" property is used.
    # containerRegistry:
    # javaOptions contains options to pass to the JVM when starting
    # up the service
    javaOptions: "-XX:MinRAMPercentage=80 -XX:MaxRAMPercentage=80"
    # cmdLineArgs contains additional arguments to be passed to the container's CMD.
    cmdLineArgs: []
    # quarkusConfigLocations contains resources that the Quarkus based variant of the component should read
    # additional configuration from.
    # Properties are read in the following sequence with properties further down in the list overwriting property
    # values read from resources further up in the list.
    # 1. Properties defined in file "/opt/hono/application.yml".
    # 2. Properties read from the resources defined here.
    # 3. Properties defined in operating system environment variables.
    # 4. Properties defined in Java system properties.
    # See https://smallrye.io/docs/smallrye-config/config/config.html#locations for details regarding supported resource
    # types.
    # If not set, default resources configuring logging levels based on the value of "quarkusLoggingProfile" are
    # being read.
    quarkusConfigLocations:
    # quarkusLoggingProfile indicates at which level the Quarkus based variant of the component should log.
    # Supported values are "prod", "dev" or "trace"
    quarkusLoggingProfile: "dev"
    # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's liveness probe.
    # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
    livenessProbeInitialDelaySeconds:
    # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's readiness probe.
    # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
    readinessProbeInitialDelaySeconds:
    # probes allows you to overwrite the global probes config values for this specific component
    probes: {}
    # resources contains the container's requests and limits for CPU and memory
    # as defined by the Kubernetes API.
    # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    # for a description of the properties' semantics.
    resources:
      requests:
        cpu: "150m"
        memory: "300Mi"
      limits:
        cpu: "1"
        memory: "512Mi"

    svc:
      annotations: {}
      loadBalancerIP:

    deployment:
      annotations: {}

    pod:
      labels: {}
      annotations: {}
      priorityClassName: ""
      affinity: {}

    # extraVolumes contains additional kubernetes Volume definitions representing volumes
    # that can mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
    # This can be used to provide the container access to files contained in kubernetes
    # Secrets and/or ConfigMaps.
    extraVolumes: []

    # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
    # should be mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
    # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
    # file system and then refer to the contained files in the component's configuration,
    # e.g. public and private keys or an application.yaml file.
    extraVolumeMounts: []

    # The configMap to get additional environment variables from for this adapter.
    envConfigMap:
    # The secret to get additional environment variables from for this adapter.
    envSecret:

    # tlsKeysSecret identifies the Secret that contains the key material which should be used for
    # securing the component's exposed API endpoint(s).
    #
    # Possible values are:
    # "example" - create and use example keys, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a private key file
    #              named "tls.key" and an X.509 certificate file named "tls.crt".
    #              The file names have been chosen deliberately to match those produced by the
    #              cert-manager operator (https://cert-manager.io/).
    # "none" - do not create keys nor mount an existing secret containing keys
    tlsKeysSecret: "example"

    # tlsTrustStoreConfigMap identifies the ConfigMap that contains the certificates which should
    # be used as the trust anchor by this component when it needs to authenticate server identities
    # during a TLS handshake.
    #
    # Possible values are:
    # "example" - create and use example CA certificates, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a PEM file
    #              named "ca.crt" which contains X.509 certificates to be used as the trust anchor.
    # "none" - do not mount an existing secret containing certificates. This might be useful if the
    #          component does not open any TLS connections to other hosts.
    tlsTrustStoreConfigMap: "example"

    # hono contains the adapter's configuration properties
    hono:
      app:
        # maxInstances defines the number of adapter Verticle instances to deploy
        # to the vert.x runtime during start-up.
        maxInstances: 1

      # lora contains configuration properties for the adapter's
      # exposed HTTP endpoints.
      # If not set, the adapter by default exposes the secure and insecure ports
      # using an example key and certificate.
      lora: {}
      #  insecurePortEnabled: true
      #  insecurePortBindAddress: "0.0.0.0"

  mqtt:
    # enabled indicates if Hono's MQTT 3.1.1 adapter should be deployed.
    enabled: true
    # imageName contains the name (excluding registry)
    # of the container image to use for the MQTT adapter
    imageName: "eclipse/hono-adapter-mqtt"
    # imageTag contains the tag of the container image to deploy.
    # If not specified, the value of the honoImagesTag property is used.
    # imageTag:
    # containerRegistry contains the name of the container registry to pull
    # the image from.
    # If not specified, the value of the "honoContainerRegistry" property is used.
    # containerRegistry:
    # javaOptions contains options to pass to the JVM when starting
    # up the service
    javaOptions: "-XX:MinRAMPercentage=80 -XX:MaxRAMPercentage=80"
    # cmdLineArgs contains additional arguments to be passed to the container's CMD.
    cmdLineArgs: []
    # quarkusConfigLocations contains resources that the Quarkus based variant of the component should read
    # additional configuration from.
    # Properties are read in the following sequence with properties further down in the list overwriting property
    # values read from resources further up in the list.
    # 1. Properties defined in file "/opt/hono/application.yml".
    # 2. Properties read from the resources defined here.
    # 3. Properties defined in operating system environment variables.
    # 4. Properties defined in Java system properties.
    # See https://smallrye.io/docs/smallrye-config/config/config.html#locations for details regarding supported resource
    # types.
    # If not set, default resources configuring logging levels based on the value of "quarkusLoggingProfile" are
    # being read.
    quarkusConfigLocations:
    # quarkusLoggingProfile indicates at which level the Quarkus based variant of the component should log.
    # Supported values are "prod", "dev" or "trace"
    quarkusLoggingProfile: "dev"
    # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's liveness probe.
    # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
    livenessProbeInitialDelaySeconds:
    # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's readiness probe.
    # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
    readinessProbeInitialDelaySeconds:
    # probes allows you to overwrite the global probes config values for this specific component
    probes: {}
    # resources contains the container's requests and limits for CPU and memory
    # as defined by the Kubernetes API.
    # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    # for a description of the properties' semantics.
    resources:
      requests:
        cpu: "150m"
        memory: "300Mi"
      limits:
        cpu: "1"
        memory: "512Mi"

    svc:
      annotations: {}
      loadBalancerIP:

    deployment:
      annotations: {}

    pod:
      labels: {}
      annotations: {}
      priorityClassName: ""
      affinity: {}

    # extraVolumes contains additional kubernetes Volume definitions representing volumes
    # that can mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
    # This can be used to provide the container access to files contained in kubernetes
    # Secrets and/or ConfigMaps.
    extraVolumes: []

    # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
    # should be mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
    # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
    # file system and then refer to the contained files in the component's configuration,
    # e.g. public and private keys or an application.yaml file.
    extraVolumeMounts: []

    # The configMap to get additional environment variables from for this adapter.
    envConfigMap:
    # The secret to get additional environment variables from for this adapter.
    envSecret:

    # tlsKeysSecret identifies the Secret that contains the key material which should be used for
    # securing the component's exposed API endpoint(s).
    #
    # Possible values are:
    # "example" - create and use example keys, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a private key file
    #              named "tls.key" and an X.509 certificate file named "tls.crt".
    #              The file names have been chosen deliberately to match those produced by the
    #              cert-manager operator (https://cert-manager.io/).
    # "none" - do not create keys nor mount an existing secret containing keys
    tlsKeysSecret: "example"

    # tlsTrustStoreConfigMap identifies the ConfigMap that contains the certificates which should
    # be used as the trust anchor by this component when it needs to authenticate server identities
    # during a TLS handshake.
    #
    # Possible values are:
    # "example" - create and use example CA certificates, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a PEM file
    #              named "ca.crt" which contains X.509 certificates to be used as the trust anchor.
    # "none" - do not mount an existing secret containing certificates. This might be useful if the
    #          component does not open any TLS connections to other hosts.
    tlsTrustStoreConfigMap: "example"

    # hono contains the adapter's configuration properties as defined in
    # https://www.eclipse.org/hono/docs/admin-guide/mqtt-adapter-config/
    hono:
      app:
        # maxInstances defines the number of adapter Verticle instances to deploy
        # to the vert.x runtime during start-up.
        maxInstances: 1

      # mqtt contains configuration properties for the adapter's
      # exposed MQTT endpoints.
      # If not set, the adapter by default exposes the secure and insecure ports
      # using an example key and certificate.
      mqtt: {}
      #  insecurePortEnabled: true
      #  insecurePortBindAddress: "0.0.0.0"

# authServer contains configuration properties for the Auth Server component.
authServer:

  # imageName contains the name (excluding registry)
  # of the container image to use for the Auth Server
  imageName: "eclipse/hono-service-auth"
  # imageTag contains the tag of the container image to deploy.
  # If not specified, the value of the honoImagesTag property is used.
  # imageTag:
  # containerRegistry contains the name of the container registry to pull
  # the image from.
  # If not specified, the value of the "honoContainerRegistry" property is used.
  # containerRegistry:
  # javaOptions contains options to pass to the JVM when starting
  # up the service
  javaOptions: "-XX:MinRAMPercentage=80 -XX:MaxRAMPercentage=80"
  # cmdLineArgs contains additional arguments to be passed to the container's CMD.
  cmdLineArgs: []
  # quarkusConfigLocations contains resources that the component should read
  # additional configuration from.
  # Properties are read in the following sequence with properties further down in the list overwriting property
  # values read from resources further up in the list.
  # 1. Properties defined in file "/opt/hono/config/application.yml".
  # 2. Properties read from the resources defined here.
  # 3. Properties defined in operating system environment variables.
  # 4. Properties defined in Java system properties.
  # See https://smallrye.io/docs/smallrye-config/config/config.html#locations for details regarding supported resource
  # types.
  # If not set, default resources configuring logging levels based on the value of "quarkusLoggingProfile" are
  # being read.
  quarkusConfigLocations:
  # quarkusLoggingProfile indicates at which level the Quarkus based variant of the component should log.
  # Supported values are "prod", "dev" or "trace"
  quarkusLoggingProfile: "dev"
  # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
  # configuration property of the component's liveness probe.
  # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
  livenessProbeInitialDelaySeconds:
  # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
  # configuration property of the component's readiness probe.
  # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
  readinessProbeInitialDelaySeconds:
  # probes allows you to overwrite the global probes config values for this specific component
  probes: {}
  # resources contains the container's requests and limits for CPU and memory
  # as defined by the Kubernetes API.
  # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  # for a description of the properties' semantics.
  resources:
    requests:
      cpu: "100m"
      memory: "196Mi"
    limits:
      cpu: "1"
      memory: "256Mi"

  deployment:
    annotations: {}

  pod:
    labels: {}
    annotations: {}
    priorityClassName: ""
    affinity: {}

  # extraVolumes contains additional kubernetes Volume definitions representing volumes
  # that can mounted into the container's file system.
  # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
  # This can be used to provide the container access to files contained in kubernetes
  # Secrets and/or ConfigMaps.
  extraVolumes: []

  # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
  # should be mounted into the container's file system.
  # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
  # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
  # file system and then refer to the contained files in the component's configuration,
  # e.g. public and private keys or an application.yaml file.
  extraVolumeMounts: []

  # envConfigMap may be used to set the name of a (already existing) ConfigMap
  # that contains additional environment variables that should be set on the
  # component's container.
  envConfigMap:
  # envSecret may be used to set the name of a (already existing) Secret
  # that contains additional environment variables that should be set on the
  # component's container.
  envSecret:

  # tlsKeysSecret identifies the Secret that contains the key material which should be used for
  # securing the component's exposed API endpoint(s).
  #
  # Possible values are:
  # "example" - create and use example keys, DO NOT USE IN PRODUCTION!!!
  # secretName - the name of an already existing secret which contains (at least) a private key file
  #              named "tls.key" and an X.509 certificate file named "tls.crt".
  #              The file names have been chosen deliberately to match those produced by the
  #              cert-manager operator (https://cert-manager.io/).
  # "none" - do not create keys nor mount an existing secret containing keys
  tlsKeysSecret: "example"

  # hono contains the Auth Server's configuration properties as defined in
  # https://www.eclipse.org/hono/docs/admin-guide/auth-server-config/
  hono:
    app:
      # maxInstances defines the number of adapter Verticle instances to deploy
      # to the vert.x runtime during start-up.
      maxInstances: 1
    auth:
      # svc contains configuration properties for the server
      svc:
        permissionsPath: "file:///opt/hono/config/permissions.json"
        supportedSaslMechanisms: "PLAIN"
        signing:
          # tokenExpiration contains the number of seconds after which tokens issued
          # by the Auth server will expire.
          tokenExpiration: 3600
      # amqp contains configuration properties for the server's
      # exposed AMQP endpoints.
      # If not set, the sever by default exposes the secure and insecure ports
      # using an example key and certificate.
      amqp: {}
      #  insecurePortEnabled: true
      #  insecurePortBindAddress: "0.0.0.0"

# deviceRegistryExample contains configuration properties for the
# example Device Registry.
deviceRegistryExample:

  # enabled indicates whether the example Device Registry
  # should be deployed and used.
  # If this property is set to false, then the protocol adapters need to be
  # explicitly configured for connecting to the Tenant, Device Registration,
  # and Credentials services using properties
  # - "adapters.tenantSpec"
  # - "adapters.deviceRegistrationSpec"
  # - "adapters.credentialsSpec"
  enabled: true

  # Sets the type of the device registry to be deployed. The following types are defined:
  # - embedded: Embedded JDBC based device registry. Also refer to the section "embeddedJdbcDeviceRegistry"
  # for additional configuration.
  # - mongodb: MongoDB based device registry. Also refer to the section "mongoDBBasedDeviceRegistry"
  # for additional configuration.
  # - jdbc: JDBC based device registry. Also refer to the section "jdbcBasedDeviceRegistry"
  # for additional configuration.
  type: "embedded"

  # addExampleData indicates whether example data is inserted after the device registry is deployed
  addExampleData: true

  # javaOptions contains options to pass to the JVM when starting
  # up the service
  javaOptions: "-XX:MinRAMPercentage=80 -XX:MaxRAMPercentage=80"
  # resources contains the container's requests and limits for CPU and memory
  # as defined by the Kubernetes API.
  # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  # for a description of the properties' semantics.
  resources:
    requests:
      cpu: "150m"
      memory: "300Mi"
    limits:
      cpu: "1"
      memory: "300Mi"

  svc:
    annotations: {}
    loadBalancerIP:

  # extraVolumes contains additional kubernetes Volume definitions representing volumes
  # that can mounted into the container's file system.
  # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
  # This can be used to provide the container access to files contained in kubernetes
  # Secrets and/or ConfigMaps.
  extraVolumes: []

  # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
  # should be mounted into the container's file system.
  # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
  # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
  # file system and then refer to the contained files in the component's configuration,
  # e.g. public and private keys or an application.yaml file.
  extraVolumeMounts: []

  # tlsKeysSecret identifies the Secret that contains the key material which should be used for
  # securing the component's exposed API endpoint(s).
  #
  # Possible values are:
  # "example" - create and use example keys, DO NOT USE IN PRODUCTION!!!
  # secretName - the name of an already existing secret which contains (at least) a private key file
  #              named "tls.key" and an X.509 certificate file named "tls.crt".
  #              The file names have been chosen deliberately to match those produced by the
  #              cert-manager operator (https://cert-manager.io/).
  # "none" - do not create keys nor mount an existing secret containing keys
  tlsKeysSecret: "example"

  # tlsTrustStoreConfigMap identifies the ConfigMap that contains the certificates which should
  # be used as the trust anchor by this component when it needs to authenticate server identities
  # during a TLS handshake.
  #
  # Possible values are:
  # "example" - create and use example CA certificates, DO NOT USE IN PRODUCTION!!!
  # secretName - the name of an already existing secret which contains (at least) a PEM file
  #              named "ca.crt" which contains X.509 certificates to be used as the trust anchor.
  # "none" - do not mount an existing secret containing certificates. This might be useful if the
  #          component does not open any TLS connections to other hosts.
  tlsTrustStoreConfigMap: "example"

  # clientTrustStorePath points to the trustStore the client of this example Device Registry should use to verify the certificates.
  # This can be used when using your own certificates in combination with the example Device Registry
  clientTrustStorePath:

  # hono contains the Device Registry's configuration properties as defined in
  # https://www.eclipse.org/hono/docs/admin-guide/device-registry-config/
  hono:
    # auth contains Hono client properties used by the example registry for
    # connecting to the Authentication service.
    # If not set, the registry by default uses the Auth Server component to
    # authenticate clients.
    auth:
    registry:
      # amqp contains configuration properties for the server's
      # exposed AMQP endpoints.
      # If not set, the registry by default exposes the secure port
      # using an example key and certificate.
      amqp: {}
      #  insecurePortEnabled: true
      #  insecurePortBindAddress: "0.0.0.0"

      # http contains configuration properties for the server's
      # exposed HTTP endpoints.
      # If not set, the registry by default exposes the insecure and secure ports
      # using an example key and certificate.
      # NOTE: For the file based device registry use "rest" instead of "http".
      http: {}
      #  insecurePortEnabled: true
      #  insecurePortBindAddress: "0.0.0.0"

      # svc contains configuration properties for the registry's service implementation.
      svc: {}
      #  maxDevicesPerTenant: 100

    # kafka contains the configuration used by the device registry
    # for connecting to a Kafka cluster to be used for messaging.
    # This property will be used if "messagingNetworkTypes" contains "kafka" and
    # "kafkaMessagingClusterExample.enabled" is set to false. Please refer to
    # https://www.eclipse.org/hono/docs/admin-guide/jdbc-device-registry-config/#kafka-based-messaging-configuration
    # or
    # https://www.eclipse.org/hono/docs/admin-guide/mongodb-device-registry-config/#kafka-based-messaging-configuration
    # for a description of supported properties.
    kafka: {}
      # commonClientConfig contains Kafka client configuration to be used by all Kafka consumers and producers
      # created by the device registry.
      # If this property is not set or if it does not contain a "bootstrap.servers" property, the
      # "adapters.kafkaMessagingSpec.commonClientConfig" property is used as a fall back.
    #  commonClientConfig:
    #    "bootstrap.servers": "broker0.my-custom-kafka.org:9092,broker1.my-custom-kafka.org:9092"
    #  event:
    #    producerConfig:
    #      "compression.type": none
    #  notification:
    #    producerConfig:
    #      "compression.type": none

  # embeddedJdbcDeviceRegistry contains configuration properties specific to the
  # embedded JDBC device registry.
  embeddedJdbcDeviceRegistry:
    # imageName contains the name (excluding registry)
    # of the container image for the example embedded jdbc device registry.
    imageName: "eclipse/hono-service-device-registry-jdbc"
    # imageTag contains the tag of the container image to deploy.
    # If not specified, the value of the honoImagesTag property is used.
    # imageTag:
    # containerRegistry contains the name of the container registry to pull
    # the image from.
    # If not specified, the value of the "honoContainerRegistry" property is used.
    # containerRegistry:
    # storageClass indicates the name of the kubernetes StorageClass that
    # should be used for the example registry's persistent volume claim.
    # If not set, the cluster's default storage class is used.
    storageClass:
    # storageSize contains the size of the storage that will be created using the
    # storageClass or the cluster's default configuration.
    # If no value is specified, the default value will be assumed.
    storageSize: 1Mi
    # cmdLineArgs contains additional arguments to be passed to the container's CMD.
    cmdLineArgs: []
    # quarkusConfigLocations contains resources that the Quarkus based variant of the component should read
    # additional configuration from.
    # Properties are read in the following sequence with properties further down in the list overwriting property
    # values read from resources further up in the list.
    # 1. Properties defined in file "/opt/hono/application.yml".
    # 2. Properties read from the resources defined here.
    # 3. Properties defined in operating system environment variables.
    # 4. Properties defined in Java system properties.
    # See https://smallrye.io/docs/smallrye-config/config/config.html#locations for details regarding supported resource
    # types.
    # If not set, default resources configuring logging levels based on the value of "quarkusLoggingProfile" are
    # being read.
    quarkusConfigLocations:
    # quarkusLoggingProfile indicates at which level the Quarkus based variant of the component should log.
    # Supported values are "prod", "dev" or "trace"
    quarkusLoggingProfile: "dev"
    # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's liveness probe.
    # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
    livenessProbeInitialDelaySeconds:
    # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's readiness probe.
    # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
    readinessProbeInitialDelaySeconds:
    # probes allows you to overwrite the global probes config values for this specific component
    probes: {}
    # resources contains the container's requests and limits for CPU and memory
    # as defined by the Kubernetes API.
    # If not specified here, then the values from "deviceRegistryExample.resources" are used.
    # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    # for a description of the properties' semantics.
    resources:
      requests:
        cpu: "200m"
        memory: "400Mi"
      limits:
        cpu: "1"
        memory: "500Mi"

    pod:
      labels: {}
      annotations: {}
      priorityClassName: ""
      affinity: {}

    # The configMap to get additional environment variables from for this device registry.
    envConfigMap:
    # The secret to get additional environment variables from for this device registry.
    envSecret:

  # mongoDBBasedDeviceRegistry contains configuration properties specific to the
  # MongoDB based device registry.
  mongoDBBasedDeviceRegistry:
    # imageName contains the name (excluding registry)
    # of the container image for the example MongoDB based device registry.
    imageName: "eclipse/hono-service-device-registry-mongodb"
    # imageTag contains the tag of the container image to deploy.
    # If not specified, the value of the honoImagesTag property is used.
    # imageTag:
    # containerRegistry contains the name of the container registry to pull
    # the image from.
    # If not specified, the value of the "honoContainerRegistry" property is used.
    # containerRegistry:
    # cmdLineArgs contains additional arguments to be passed to the container's CMD.
    cmdLineArgs: []
    # quarkusConfigLocations contains resources that the Quarkus based variant of the component should read
    # additional configuration from.
    # Properties are read in the following sequence with properties further down in the list overwriting property
    # values read from resources further up in the list.
    # 1. Properties defined in file "/opt/hono/application.yml".
    # 2. Properties read from the resources defined here.
    # 3. Properties defined in operating system environment variables.
    # 4. Properties defined in Java system properties.
    # See https://smallrye.io/docs/smallrye-config/config/config.html#locations for details regarding supported resource
    # types.
    # If not set, default resources configuring logging levels based on the value of "quarkusLoggingProfile" are
    # being read.
    quarkusConfigLocations:
    # quarkusLoggingProfile indicates at which level the Quarkus based variant of the component should log.
    # Supported values are "prod", "dev" or "trace"
    quarkusLoggingProfile: "dev"
    # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's liveness probe.
    # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
    livenessProbeInitialDelaySeconds:
    # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's readiness probe.
    # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
    readinessProbeInitialDelaySeconds:
    # probes allows you to overwrite the global probes config values for this specific component
    probes: {}
    # If not specified here, then the values from "deviceRegistryExample.resources" are used.
    # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    # for a description of the properties' semantics.
    resources:
      requests:
        cpu: "150m"
        memory: "400Mi"
      limits:
        cpu: "1"
        memory: "400Mi"


    # mongodb contains the configuration properties to connect to the MongoDB database instance.
    # If you would like to use an already existing MongoDB database instance, then configure
    # the below section accordingly. Note that the values are processed via the 'tpl' function here,
    # allowing for example the inclusion of the release name in the 'host' property.
    mongodb: {}
    # The host name or IP address of the MongoDB instance.
    # host:
    # The port that the MongoDB instance is listening on.
    # port:
    # The name of the MongoDB database to be used by the device registry application.
    # dbName:
    # The user name to use for authenticating to the MongoDB instance.
    # username:
    # The password to use for authenticating to the MongoDB instance.
    # password:

    # The configMap to get additional environment variables from for this device registry.
    envConfigMap:
    # The secret to get additional environment variables from for this device registry.
    envSecret:

    deployment:
      annotations: {}

    pod:
      labels: {}
      annotations: {}
      priorityClassName: ""
      affinity: {}

  # jdbcBasedDeviceRegistry contains configuration properties specific to the
  # jdbc based device registry.
  jdbcBasedDeviceRegistry:
    # imageName contains the name (excluding registry)
    # of the container image for the example jdbc based device registry.
    imageName: "eclipse/hono-service-device-registry-jdbc"
    # imageTag contains the tag of the container image to deploy.
    # If not specified, the value of the honoImagesTag property is used.
    # imageTag:
    # containerRegistry contains the name of the container registry to pull
    # the image from.
    # If not specified, the value of the "honoContainerRegistry" property is used.
    # containerRegistry:
    # cmdLineArgs contains additional arguments to be passed to the container's CMD.
    cmdLineArgs: []
    # quarkusConfigLocations contains resources that the Quarkus based variant of the component should read
    # additional configuration from.
    # Properties are read in the following sequence with properties further down in the list overwriting property
    # values read from resources further up in the list.
    # 1. Properties defined in file "/opt/hono/application.yml".
    # 2. Properties read from the resources defined here.
    # 3. Properties defined in operating system environment variables.
    # 4. Properties defined in Java system properties.
    # See https://smallrye.io/docs/smallrye-config/config/config.html#locations for details regarding supported resource
    # types.
    # If not set, default resources configuring logging levels based on the value of "quarkusLoggingProfile" are
    # being read.
    quarkusConfigLocations:
    # quarkusLoggingProfile indicates at which level the Quarkus based variant of the component should log.
    # Supported values are "prod", "dev" or "trace"
    quarkusLoggingProfile: "dev"
    # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's liveness probe.
    # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
    livenessProbeInitialDelaySeconds:
    # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's readiness probe.
    # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
    readinessProbeInitialDelaySeconds:
    # probes allows you to overwrite the global probes config values for this specific component
    probes: {}
    # If not specified here, then the values from "deviceRegistryExample.resources" are used.
    # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    # for a description of the properties' semantics.
    resources:
    # registry.jdbc contains the configuration properties for device registry
    # to connect to the database.

    # The configMap to get additional environment variables from for this device registry.
    envConfigMap:
    # The secret to get additional environment variables from for this device registry.
    envSecret:

    deployment:
      annotations: {}

    pod:
      labels: {}
      annotations: {}
      priorityClassName: ""
      affinity: {}

    registry:
      jdbc:
        # the jdbc properties for read-only operations
        adapter:
          # The jdbc URL for the database
          url:
          # The jdbc driver class name
          driverClass:
          # The user name to use for authenticating to the database
          username:
          # The password to use for authenticating to the database
          password:
        # the jdbc properties for write operations
        management:
          # The jdbc URL for the database. For SQLServer, ";SelectMethod=Cursor" is required in the management url.
          url:
          # The jdbc driver class name
          driverClass:
          # The user name to use for authenticating to the database
          username:
          # The password to use for authenticating to the database
          password:
    # tenant.jdbc contains the configuration properties for tenant registry
    # to connect to the database.
    tenant:
      jdbc:
        # the jdbc properties for read-only operations
        adapter:
          # The jdbc URL for the database
          url:
          # The jdbc driver class name
          driverClass:
          # The user name to use for authenticating to the database
          username:
          # The password to use for authenticating to the database
          password:
        # the jdbc properties for write operations
        management:
          # The jdbc URL for the database. For SQLServer, ";SelectMethod=Cursor" is required in the management url.
          url:
          # The jdbc driver class name
          driverClass:
          # The user name to use for authenticating to the database
          username:
          # The password to use for authenticating to the database
          password:

# mongodb contains configuration properties for the example MongoDB instance to be used with the
# MongoDB device registry.
# By default, a standalone instance using a k8s Deployment instead of a StatefulSet will be created.
# The configuration properties below are intended to set up a MongoDB instance that is sufficient
# for demonstration and/or testing purposes. In order to use a production level MongoDB instance, users
# should not adapt these properties, but instead set the "createInstance" property to false, set up a
# separate MongoDB instance and configure the registry's connection details under
# "deviceRegistryExample.mongoDBBasedDeviceRegistry.mongodb".
mongodb:
  # createInstance indicates whether a MongoDB database instance should be created.
  createInstance: false
  # do not use the default name ("mongodb") because it will lead to a config
  # property name clash in the device registry pod when using "hono" as the release name
  nameOverride: "monogodb-server"
  # run single node instance
  architecture: "standalone"
  # Use StatefulSet instead of Deployment when deploying standalone
  useStatefulSet: false
  # If authentication to be enabled or not.
  # ref: https://docs.mongodb.com/manual/tutorial/enable-authentication/
  auth:
    enabled: true
    # Configure a custom MongoDB database with a user name and password.
    # And also set a root password for the MongoDB instance.
    # ref: https://github.com/bitnami/bitnami-docker-mongodb/blob/master/README.md#creating-a-user-and-database-on-first-run
    rootPassword: "root-secret"
    usernames:
    - "device-registry@HONO"
    passwords:
    - "hono-secret"
    databases:
    - "honodb"
  # Configure the MongoDB service to be accessed from inside the cluster only.
  service:
    type: ClusterIP
    ports:
      mongodb: 27017
    annotations: {}

# commandRouterService contains configuration properties for the
# Command Router service.
commandRouterService:

  # imageName contains the name (excluding registry)
  # of the container image to use for the Command Router service
  imageName: "eclipse/hono-service-command-router"
  # imageTag contains the tag of the container image to deploy.
  # If not specified, the value of the honoImagesTag property is used.
  # imageTag:
  # containerRegistry contains the name of the container registry to pull
  # the image from.
  # If not specified, the value of the "honoContainerRegistry" property is used.
  # containerRegistry:
  # javaOptions contains options to pass to the JVM when starting
  # up the service
  javaOptions: "-XX:MinRAMPercentage=80 -XX:MaxRAMPercentage=80 -Djava.security.properties=/opt/hono/config/dns-cache-config.properties"
  # cmdLineArgs contains additional arguments to be passed to the container's CMD.
  cmdLineArgs: []
  # quarkusConfigLocations contains resources that the Quarkus based variant of the component should read
  # additional configuration from.
  # Properties are read in the following sequence with properties further down in the list overwriting property
  # values read from resources further up in the list.
  # 1. Properties defined in file "/opt/hono/application.yml".
  # 2. Properties read from the resources defined here.
  # 3. Properties defined in operating system environment variables.
  # 4. Properties defined in Java system properties.
  # See https://smallrye.io/docs/smallrye-config/config/config.html#locations for details regarding supported resource
  # types.
  # If not set, default resources configuring logging levels based on the value of "quarkusLoggingProfile" are
  # being read.
  quarkusConfigLocations:
  # quarkusLoggingProfile indicates at which level the Quarkus based variant of the component should log.
  # Supported values are "prod", "dev" or "trace"
  quarkusLoggingProfile: "dev"
  # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
  # configuration property of the component's liveness probe.
  # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
  livenessProbeInitialDelaySeconds:
  # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
  # configuration property of the component's readiness probe.
  # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
  readinessProbeInitialDelaySeconds:
  # probes allows you to overwrite the global probes config values for this specific component
  probes: {}
  # resources contains the container's requests and limits for CPU and memory
  # as defined by the Kubernetes API.
  # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  # for a description of the properties' semantics.
  resources:
    requests:
      cpu: "150m"
      memory: "256Mi"
    limits:
      cpu: "1"
      memory: "512Mi"

  svc:
    annotations: {}

  deployment:
    annotations: {}

  pod:
    labels: {}
    annotations: {}
    priorityClassName: ""
    affinity: {}

  # extraVolumes contains additional kubernetes Volume definitions representing volumes
  # that can mounted into the container's file system.
  # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
  # This can be used to provide the container access to files contained in kubernetes
  # Secrets and/or ConfigMaps.
  extraVolumes: []

  # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
  # should be mounted into the container's file system.
  # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
  # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
  # file system and then refer to the contained files in the component's configuration,
  # e.g. public and private keys or an application.yaml file.
  extraVolumeMounts: []

  # The configMap to get additional environment variables from for this command router service.
  envConfigMap:
  # The secret to get additional environment variables from for this command router service.
  envSecret:

  # tlsKeysSecret identifies the Secret that contains the key material which should be used for
  # securing the component's exposed API endpoint(s).
  #
  # Possible values are:
  # "example" - create and use example keys, DO NOT USE IN PRODUCTION!!!
  # secretName - the name of an already existing secret which contains (at least) a private key file
  #              named "tls.key" and an X.509 certificate file named "tls.crt".
  #              The file names have been chosen deliberately to match those produced by the
  #              cert-manager operator (https://cert-manager.io/).
  # "none" - do not create keys nor mount an existing secret containing keys
  tlsKeysSecret: "example"

  # tlsTrustStoreConfigMap identifies the ConfigMap that contains the certificates which should
  # be used as the trust anchor by this component when it needs to authenticate server identities
  # during a TLS handshake.
  #
  # Possible values are:
  # "example" - create and use example CA certificates, DO NOT USE IN PRODUCTION!!!
  # secretName - the name of an already existing secret which contains (at least) a PEM file
  #              named "ca.crt" which contains X.509 certificates to be used as the trust anchor.
  # "none" - do not mount an existing secret containing certificates. This might be useful if the
  #          component does not open any TLS connections to other hosts.
  tlsTrustStoreConfigMap: "example"

  # clientTrustStorePath points to the trustStore the client of this command router service should use to verify the certificates.
  # This can be used when using your own certificates in combination with this command router service.
  clientTrustStorePath:

  # hono contains the service's configuration properties as defined in
  # https://www.eclipse.org/hono/docs/admin-guide/command-router-config/
  hono:
    app:
      # maxInstances defines the number of adapter Verticle instances to deploy
      # to the vert.x runtime during start-up.
      maxInstances: 1
    # auth contains Hono client properties used by the service for
    # connecting to the Authentication service.
    # If not set, the service by default uses the Auth Server component to
    # authenticate clients.
    auth:
    commandRouter:
      # amqp contains configuration properties for the server's
      # exposed AMQP endpoints.
      # If not set, the registry by default exposes the secure port
      # using an example key and certificate.
      amqp:
      #  insecurePortEnabled: true
      #  insecurePortBindAddress: "0.0.0.0"

      # cache contains properties configuring the embedded or remote cache that
      # the Command Router uses for storing routing information. Please refer to Hono's Command Router admin guide at
      # https://www.eclipse.org/hono/docs/admin-guide/command-router-config/#data-grid-connection-configuration for
      # details regarding cache configuration.
      # If not set explicitly here and "dataGridExample.enabled" is "true", the example data grid is used.
      # If "dataGridExample.enabled" is "false", an embedded cache with a default configuration will be used.
      # Note that when using the embedded cache, the Command Router pod does NOT support scaling up to a replica
      # count > 1
      cache:

    # kafka contains the configuration used by the command router
    # for connecting to a Kafka cluster to be used for messaging.
    # This property will be used if "messagingNetworkTypes" contains "kafka" and
    # "kafkaMessagingClusterExample.enabled" is set to false. Please refer to
    # https://www.eclipse.org/hono/docs/admin-guide/command-router-config/#kafka-based-messaging-configuration
    # for a description of supported properties.
    kafka: {}
      # commonClientConfig contains Kafka client configuration to be used by all Kafka consumers and producers
      # created by the Command Router service.
      # If this property is not set or if it does not contain a "bootstrap.servers" property, the
      # "adapters.kafkaMessagingSpec.commonClientConfig" property is used as a fall back.
    #  commonClientConfig:
    #    "bootstrap.servers": "broker0.my-custom-kafka.org:9092,broker1.my-custom-kafka.org:9092"
    #  cleanup:
    #    adminClientConfig:
    #      "compression.type": none
    #  command:
    #    consumerConfig:
    #      "compression.type": none
    #  commandInternal:
    #    producerConfig:
    #      "compression.type": none
    #  commandResponse:
    #    producerConfig:
    #      "compression.type": none
    #  notification:
    #    consumerConfig:
    #      "compression.type": none

prometheus:
  # createInstance indicates whether a Prometheus server should be created
  # using the Prometheus chart.
  # Set this property to true if you want the chart to install an example Prometheus server that
  # is configured to scrape Hono's components.
  # If you want to use an already existing Prometheus server, set this property to false
  # and set the "host" and "port" properties to the existing server's host name and port.
  createInstance: false
  # host contains the host name of an existing Prometheus server.
  # This property is used to configure a corresponding datasource in Grafana
  # if createInstance is set to false.
  host:
  # post contains the port number of an existing Prometheus server.
  # This property is used to configure a corresponding datasource in Grafana
  # if createInstance is set to false.
  port:

  ## Define serviceAccount names for components. Defaults to component's fully qualified name.
  ##
  serviceAccounts:
    alertmanager:
      create: false
      name:
    kubeStateMetrics:
      create: false
      name:
    nodeExporter:
      create: false
      name:
    pushgateway:
      create: false
      name:
    server:
      create: true
      name:

  server:
    configMapOverrideName: "prometheus-config"
    global:
      scrape_interval: 10s
    service:
      servicePort: 9090

  alertmanager:
    enabled: false

  kubeStateMetrics:
    enabled: false

  nodeExporter:
    enabled: false

  pushgateway:
    enabled: false

grafana:
  enabled: false
  adminPassword: "admin"

  # do not run tests after deployment
  testFramework:
    enabled: false

  ## Expose the grafana service to be accessed from outside the cluster (LoadBalancer service).
  ## or access it from within the cluster (ClusterIP service). Set the service type and the port to serve it.
  ## ref: http://kubernetes.io/docs/user-guide/services/
  ##
  service:
    type: "ClusterIP"
    port: 3000
    targetPort: 3000
    annotations: {}

  ## Sidecars that collect the configmaps with specified label and stores the included files them into the respective folders
  ## Requires at least Grafana 5 to work and can't be used together with parameters dashboardProviders, datasources and dashboards
  sidecar:
    dashboards:
      enabled: true
      # label that the configmaps with dashboards are marked with
      label: "grafana_dashboard"
    datasources:
      enabled: true
      # label that the configmaps with datasources are marked with
      label: "grafana_datasource"

  rbac:
    namespaced: true

# kafkaMessagingClusterExample contains properties for configuring an example Kafka cluster
# to be used for messaging if "messagingNetworkTypes" contains "kafka"
kafkaMessagingClusterExample:
  # enabled indicates whether the example Kafka cluster consisting of a single broker
  # and one Zookeeper instance should be deployed. This minimal deployment is not suitable
  # for production purposes. To use an already existing Kafka cluster instead,
  # set this property to false and configure "adapters.kafkaMessagingSpec".
  enabled: true

# configuration of the example Kafka cluster to be deployed if "kafkaMessagingClusterExample.enabled" is "true"
kafka:
  # the name of the template (maintains the release name)
  nameOverride: "kafka"
  # Set to false for productive setups. Topic management then needs to be provided externally.
  autoCreateTopicsEnable: true
  deleteTopicEnable: true
  auth:
    clientProtocol: "sasl_tls"
    sasl:
      jaas:
        clientUsers:
        - "hono"
        clientPasswords:
        - "hono-secret"
        zookeeperUser: "zookeeperUser"
        zookeeperPassword: "zookeeperPassword"
    tls:
      type: "pem"
      pemChainIncluded: true
      existingSecrets:
      # Evaluated in kafka chart via tpl; kafka chart full name used here!
      - '{{ include "hono.fullname" . }}-example-keys'

  service:
    ports:
      client: 9092
      internal: 9093
      external: 9094

  replicaCount: 1
  # Do not write data to a PersistentVolume by default.
  # When setting this to true, make sure to also set "kafka.zookeeper.persistence.enabled" to true and
  # make sure that Kafka is stopped cleanly using SIGTERM _before_ Zookeeper is stopped.
  # Otherwise you will most likely run into issues like
  # https://stackoverflow.com/questions/39759071/error-while-starting-kafka-broker
  persistence:
    enabled: false
  # Expose the Kafka service to be accessed from outside the cluster (LoadBalancer service).
  # To use service type NodePort instead of LoadBalancer, refer to
  # https://github.com/bitnami/charts/tree/40bf90ef4a52969b9ed8acca3d8a67e90d800673/bitnami/kafka#accessing-kafka-brokers-from-outside-the-cluster
  externalAccess:
    enabled: true
    autoDiscovery:
      enabled: true
    service:
      type: "LoadBalancer"
      ports:
        external: 9094
      # length of the array must match replicaCount
      nodePorts:
      - 32094
  serviceAccount:
    create: true
  rbac:
    # Note that this could require creating RBAC rules, for more information refer to
    # https://github.com/bitnami/charts/tree/master/bitnami/kafka#accessing-kafka-brokers-from-outside-the-cluster
    create: true
  # limit Kafka JVM's memory consumption
  heapOpts: "-Xms620M -Xmx620M"
  resources:
    requests:
      memory: "800Mi"
    limits:
      memory: "800Mi"

  zookeeper:
    persistence:
      enabled: false
    auth:
      client:
        enabled: true
        clientUser: "zookeeperUser"
        clientPassword: "zookeeperPassword"
        serverUsers: "zookeeperUser"
        serverPasswords: "zookeeperPassword"
    # limit Zookeeper JVM's memory consumption
    heapSize: 400
    resources:
      requests:
        memory: "256Mi"
      limits:
        memory: "500Mi"

# amqpMessagingNetworkExample contains properties for configuring an example AMQP network
# to be used for messaging if "messagingNetworkTypes" contains "amqp"
amqpMessagingNetworkExample:
  # enabled indicates whether the example AMQP Messaging Network
  # consisting of a single Dispatch Router and Broker should be
  # deployed and used. By default an internal Broker is deployed.
  # As alternative an external Broker can be configured as well.
  enabled: false
  # insecurePortEnabled indicates if the non-TLS secured API endpoint of the Dispatch Router
  # should be enabled or not.
  insecurePortEnabled: true

  # dispatchRouter contains properties for configuring the Qpid Dispatch Router
  dispatchRouter:
    # configPath contains the path to the configuration file of the
    # Qpid Dispatch Router configuration file
    # See http://qpid.apache.org/releases/qpid-dispatch-1.17.1/man/qdrouterd.conf.html
    configPath: "/opt/hono/config/qdrouterd.json"
    # imageName contains the name (including tag) of the container image
    # to use for the example AMQP Messaging Network's Dispatch Router.
    imageName: "quay.io/interconnectedcloud/qdrouterd:1.17.1"
    # certFile contains the absolute path to a PEM file containing
    # the X.509 certificate that the router should use for authenticating
    # to clients
    certFile: "/opt/hono/tls/tls.crt"
    # keyFile contains the absolute path to a PEM file containing
    # the private key that the router should use for authenticating
    # to clients
    keyFile: "/opt/hono/tls/tls.key"
    # trustStore contains the absolute path to a PEM file containing
    # the X.509 certificates that the router should use as trust anchors
    # when authenticating clients connecting to the router in a TLS
    # handshake
    trustStore: "/opt/hono/tls/ca.crt"
    # serverTrustStore contains the absolute path to a PEM file containing
    # the X.509 certificates that the router should use as trust anchors
    # when authenticating to servers as part of a TLS handshake
    serverTrustStore: "/opt/hono/tls/ca.crt"
    # uidFormat contains the format string to use for extracting the user ID from
    # the subject DN of certificates that clients use for authenticating to the router's
    # "internal" listener.
    # See http://qpid.apache.org/releases/qpid-dispatch-1.17.1/man/qdrouterd.conf.html
    # for details regarding the syntax.
    # The default value ("ou") extracts the Organization ("O") and the Org Unit ("OU")
    # and concatenates them using a semicolon, e.g. "Eclipse IoT;Hono"
    uidFormat: "ou"
    # adapterUids contains a comma separated list of uids of protocol adapters that authenticate
    # by means of a client certificate.
    # The default value ("Eclipse IoT;Hono") includes all adapters that authenticate with their
    # demo certificate.
    adapterUids: "Eclipse IoT;Hono"
    # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's liveness probe.
    # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
    livenessProbeInitialDelaySeconds:
    # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
    # configuration property of the component's readiness probe.
    # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
    readinessProbeInitialDelaySeconds:
    # probes allows you to overwrite the global probes config values for this specific component
    probes:
      livenessProbe:
        httpGet:
          path: "/healthz"
        periodSeconds: 9
        initialDelaySeconds: 300
      readinessProbe:
        httpGet:
          path: "/healthz"
        periodSeconds: 5
        initialDelaySeconds: 20

    pod:
      priorityClassName: ""
      affinity: {}

    svc:
      annotations: {}
      loadBalancerIP:
    # resources contains the container's requests and limits for CPU and memory
    # as defined by the Kubernetes API.
    # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    # for a description of the properties' semantics.
    resources:
      requests:
        cpu: "150m"
        memory: "64Mi"
      limits:
        cpu: "1"
        memory: "256Mi"

    # extraVolumes contains additional kubernetes Volume definitions representing volumes
    # that can mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
    # This can be used to provide the container access to files contained in kubernetes
    # Secrets and/or ConfigMaps.
    extraVolumes: []

    # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
    # should be mounted into the container's file system.
    # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
    # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
    # file system and then refer to the contained files in the component's configuration,
    # e.g. public and private keys or an application.yaml file.
    extraVolumeMounts: []

    # tlsKeysSecret identifies the Secret that contains the key material which should be used for
    # securing the component's exposed API endpoint(s).
    #
    # Possible values are:
    # "example" - create and use example keys, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a private key file
    #              named "tls.key" and an X.509 certificate file named "tls.crt".
    #              The file names have been chosen deliberately to match those produced by the
    #              cert-manager operator (https://cert-manager.io/).
    # "none" - do not create keys nor mount an existing secret containing keys
    tlsKeysSecret: "example"

    # tlsTrustStoreConfigMap identifies the ConfigMap that contains the certificates which should
    # be used as the trust anchor by this component when it needs to authenticate server identities
    # during a TLS handshake.
    #
    # Possible values are:
    # "example" - create and use example CA certificates, DO NOT USE IN PRODUCTION!!!
    # secretName - the name of an already existing secret which contains (at least) a PEM file
    #              named "ca.crt" which contains X.509 certificates to be used as the trust anchor.
    # "none" - do not mount an existing secret containing certificates. This might be useful if the
    #          component does not open any TLS connections to other hosts.
    tlsTrustStoreConfigMap: "example"

  # AMQP Messaging Network Broker configuration.
  broker:
    # saslUsername contains the username that the Dispatch Router should use
    # for authenticating to the broker
    saslUsername: "artemis"
    # saslPassword contains the password that the Dispatch Router should use
    # for authenticating to the broker
    saslPassword: "artemis"
    # port contains the port that the Dispatch Router should use
    # for connecting to the broker
    port: 5671
    # artemis contains configuration properties for the example Apache ActiveMQ Artemis broker
    artemis:
      # imageName contains the name (including tag) of the container
      # image to use for the example AMQP Messaging Network Broker
      imageName: "quay.io/artemiscloud/activemq-artemis-broker:1.0.6"
      # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
      # configuration property of the component's liveness probe.
      # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
      livenessProbeInitialDelaySeconds:
      # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
      # configuration property of the component's readiness probe.
      # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
      readinessProbeInitialDelaySeconds:
      # probes allows you to overwrite the global probes config values for this specific component
      probes:
        livenessProbe:
          periodSeconds: 17
          timeoutSeconds: 3
          initialDelaySeconds: 300
        readinessProbe:
          periodSeconds: 10
          timeoutSeconds: 3
          initialDelaySeconds: 20
      resources:
        requests:
          cpu: "150m"
          memory: "600Mi"
        limits:
          cpu: "1"
          memory: "600Mi"

      pod:
        priorityClassName: ""
        affinity: {}

      # extraVolumes contains additional kubernetes Volume definitions representing volumes
      # that can mounted into the container's file system.
      # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
      # This can be used to provide the container access to files contained in kubernetes
      # Secrets and/or ConfigMaps.
      extraVolumes: []

      # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
      # should be mounted into the container's file system.
      # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
      # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
      # file system and then refer to the contained files in the component's configuration,
      # e.g. public and private keys or an application.yaml file.
      extraVolumeMounts: []

    # servicebus contains configuration properties for the Azure ServiceBus instance that
    # should be used instead of the example Artemis broker.
    servicebus:
      # host contains the FQDN of the Azure ServiceBus endpoint to connect to.
      # If this property is set then the example Artemis broker will not be deployed
      # and the Dispatch Router will be configured to connect to the ServiceBus.
      host:

# dataGridExample contains properties for configuring an example data grid
# to be used by the Command Router component.
dataGridExample:
  # enabled indicates whether the example data grid should be deployed and used.
  # The default value of this property is false, meaning that the Command Router service component
  # will use in-memory storage instead of a data-grid, if not configured otherwise.
  enabled: false
  # imageName contains the name (including tag)
  # of the container image to use for the example data grid.
  imageName: "infinispan/server-native:13.0"
  # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
  # configuration property of the component's liveness probe.
  # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
  livenessProbeInitialDelaySeconds:
  # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
  # configuration property of the component's readiness probe.
  # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
  readinessProbeInitialDelaySeconds:
  # probes allows you to overwrite the global probes config values for this specific component
  probes:
    livenessProbe:
      httpGet:
        path: "/rest/v2/cache-managers/routing-info/health/status"
        port: "hotrod"
      failureThreshold: 5
      successThreshold: 1
      timeoutSeconds: 3
      initialDelaySeconds: 300
    readinessProbe:
      httpGet:
        path: "/rest/v2/cache-managers/routing-info/health/status"
        port: "hotrod"
      failureThreshold: 5
      successThreshold: 1
      timeoutSeconds: 3
      initialDelaySeconds: 30
  # resources contains the container's requests and limits for CPU and memory
  # as defined by the Kubernetes API.
  # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  # for a description of the properties' semantics.
  resources:
    requests:
      cpu: "150m"
      memory: "100Mi"
    limits:
      cpu: "1"
      memory: "200Mi"

  pod:
    priorityClassName: ""
    affinity: {}

  # authUsername contains the name of the user that is authorized to connect to the example data grid.
  authUsername: "hono"
  # authPassword contains the secret of the user that is authorized to connect to the example data grid
  authPassword: "hono-secret"
  # dataMaxSize contains the maximum size of off-heap memory used for storing data per Infinispan node
  dataMaxSize: "30 MB"

jaegerBackendExample:

  # enabled indicates whether the example Jaeger all-in-one
  # back end should be deployed and used.
  enabled: false
  # allInOneImage contains the name (including tag)
  # of the container image to use for the example Jaeger back end.
  allInOneImage: "jaegertracing/all-in-one:1.50"
  # [DEPRECATED: use probes instead] livenessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
  # configuration property of the component's liveness probe.
  # The value of the top level "livenessProbeInitialDelaySeconds" property will be used if not set.
  livenessProbeInitialDelaySeconds:
  # [DEPRECATED: use probes instead] readinessProbeInitialDelaySeconds contains the value to use for the "initialDelaySeconds"
  # configuration property of the component's readiness probe.
  # The value of the top level "readinessProbeInitialDelaySeconds" property will be used if not set.
  readinessProbeInitialDelaySeconds:
  probes:
    livenessProbe:
      initialDelaySeconds: 300
      httpGet:
        path: "/"
    readinessProbe:
      initialDelaySeconds: 10
      httpGet:
        path: "/"
  # resources contains the container's requests and limits for CPU and memory
  # as defined by the Kubernetes API.
  # Refer to https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  # for a description of the properties' semantics.
  resources:
    requests:
      cpu: "150m"
      memory: "256Mi"
    limits:
      cpu: "1"
      memory: "512Mi"
  svc:
    annotations: {}
    loadBalancerIP:

  pod:
    labels: {}
    annotations: {}
    priorityClassName: ""
    affinity: {}

  # env contains environment variables to set for the Jaeger all-in-one container.
  # The default variables configure the container to keep up to 100000 traces in memory.
  env:
  - name: "MEMORY_MAX_TRACES"
    value: "100000"

  # extraVolumes contains additional kubernetes Volume definitions representing volumes
  # that can mounted into the container's file system.
  # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volume-v1-core
  # This can be used to provide the container access to files contained in kubernetes
  # Secrets and/or ConfigMaps.
  extraVolumes: []

  # extraVolumeMounts describes how the additional volumes defined in "extraVolumes"
  # should be mounted into the container's file system.
  # The syntax is defined in https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#volumemount-v1-core
  # A common use case for this is to mount a kubernetes Secret or ConfigMap into the
  # file system and then refer to the contained files in the component's configuration,
  # e.g. public and private keys or an application.yaml file.
  extraVolumeMounts: []

  # envConfigMap contains the name of an (existing) ConfigMap to get additional environment variables from.
  envConfigMap:
  # envConfigMap contains the name of an (existing) Secret to get additional environment variables from.
  envSecret:

# otelCollectorAgentImage contains the name (including tag) of the container image
# to use for the OpenTelemetry collector agent sidecar containers.
# These containers are deployed with Hono's components if the example Jaeger all-in-one
# deployment is disabled and "otelCollectorAgentConfigMap" is not null.
otelCollectorAgentImage: "otel/opentelemetry-collector:0.86.0"
# otelCollectorAgentConfigMap can be used to specify the name of an existing ConfigMap
# from which an OpenTelemetry collector configuration should be read.
# If a ConfigMap name is given, an OpenTelemetry collector agent sidecar container will
# be deployed with each Hono component and the Hono component will send tracing data to
# that collector. The collector configuration is taken from a "otel-collector-config.yaml"
# file defined in the ConfigMap and must contain an OTLP receiver using the gRPC protocol.
# This property will only be used if "jaegerBackendExample.enabled" is set to "false".
otelCollectorAgentConfigMap:
